#ifndef _RECURSIVE_PARSER_HPP_
#define _RECURSIVE_PARSER_HPP_
#include "../lex.yy.c"

extern void next_token();
extern void init_lexer(char* arg);

void eat(int expected);
void error();
void prog();
void decl();
void consts();
void listconst();
void listconstprime();
void constdecl();
void types();
void typesprime();
void primtypes();
void primtypesprime();
void arraytype();
void subrangelist();
void subrangelistprime();
void subrangetype();
void settype();
void enumtype();
void recordtype();
void usertypes();
void listusertypes();
void listusertypesprime();
void usertype();
void vars();
void varlistlist();
void varlistlistprime();
void varlist();
void idlist();
void idlistprime();
void idattr();
void variable();
void variableprime();
void block();
void stmts();
void stmtlistprime();
void stmt();
void stmtprime();
void subprogcall();
void exitstmt();
void returnstmt();
void attrstmt();
void attrstmtprime();
void ifblock();
void elseblock();
void loopblock();
void caseblock();
void caseblockprime();
void caselist();
void literallist();
void listerallistprime();
void gotostmt();
void forblock();
void forblockprime();
void expr();
void disj();
void final_term();
void final_termprime();
void add_op();
void mul_op();
void equality_op();
void relational_op();
void conj();
void conjprime();
void comp();
void compprime();
void relational();
void relationalprime();
void sum();
void sumprime();
void neg();
void mul();
void mulprime();
void literal();
void exprlist();
void exprlist_plus();
void exprlist_plusprime();
void subprograms();
void subprogramsprime();
void procedure();
void function();
void param();
void writestmt();
void writelnstmt();
void readstmt();
void readlnstmt();

#endif /* _RECURSIVE_PARSER_HPP_ */