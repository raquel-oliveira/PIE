Foi utilizada a ferramenta yacc para construção desse parser. O yacc é uma ferramenta que gera um parser LALR(1). Este tipo de parser contém uma pilha e um input, e executa ações de acordo com uma tabela, considerando o estado no topo da pilha e o símbolo lookahead. Essas ações podem ser shift (avançar o input e empilhar um estado), reduce (desempilhar estados de uma regra, olhar tabela com estado agora no topo e símbolo não terminal da regra, empilhar o estado que a tabela informou), aceitar e erro. A construção dessa tabela, que é o que vai ditar qual ação deve ser executada, é feita a partir de um grafo de estados, onde cada estado contém uma lista de itens (regras com uma posição demarcada e um símbolo lookahead). A diferença nesse grafo ou na construção da tabela a partir dos grafos é o que diferencia os diversos parsers LR.

\section{Conflitos}
O yacc avisa quando há conflitos no parsing, ou seja, quando há mais de uma possível ação. Nossa gramática é ambígua na regra do ``else", o que causa um conflito shift/reduce (qualquer uma das duas ações poderiam ser executadas). O padrão do yacc é resolver esse conflito com o shift, e no nosso caso é isso que queremos pois desse modo a interpretação é que o ``else" é combinado com o ``if" mais recente, então não fazemos nada e deixamos o yacc mesmo resolver.

\section{Saída do Analisador}
Na saída padrão, o analisador informa os erros encontrados no programa. Se não houver error, não há nada na saída padrão, que é o caso para os exemplos. Ao informar um erro, o analisador indica qual a sua linha e coluna, além de qual token não era esperado.
Além disso, o output do analisador inclui um arquivo de texto, que contém o pretty printing do programa de entrada; isto é, uma impressão ``bonita" do programa de entrada, toda devidamente identada. O pretty printing pode não ocorrer corretamente quando há erros no programa. Para todos os exemplos, o pretty printing é feito perfeitamente.

\section{Recuperação de Erro}
Para recuperação de erro, foi usado o token ``error" do próprio yacc, que ele reconhece como um símbolo terminal e desempilha a pilha e descarta símbolos da entrada até que possa retornar ao parsing normal. Esse token é usado criando novas regras e o adicionando onde erros são esperados. No nosso caso, adicionamos esse token antes do `;' que separa statements, por exemplo. Desse modo, quando há um erro em um statement, as coisas entre o erro e o próximo `;' (que simboliza o fim desse statement) são ignoradas. Dessa forma, quando um erro é encontrado ele ainda é reportado, mas a execução do programa não é interrompida, podendo informar sobre diversos erros de uma vez. O único problema é que, por ignorar algumas coisas depois de um erro, também ignora algumas ações semânticas que fazem o pretty printing, fazendo com que o resultado não fique como esperado. Portanto o pretty printing atualmente não funciona para códigos que não estejam 100\% corretos sintáticamente.